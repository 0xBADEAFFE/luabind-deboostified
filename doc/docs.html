<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.1: http://docutils.sourceforge.net/" />
<title>luabind</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="luabind">
<h1 class="title">luabind</h1>
<p>Note: This library is currently in public beta phase. This documentation 
should be considered beta as well. Please report any grammatical 
corrections/spelling corrections.</p>
<div class="contents topic" id="contents">
<p class="topic-title"><a name="contents">Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#introduction" id="id1" name="id1">1   Introduction</a></li>
<li><a class="reference" href="#features" id="id2" name="id2">2   Features</a></li>
<li><a class="reference" href="#portability" id="id3" name="id3">3   Portability</a></li>
<li><a class="reference" href="#building-luabind" id="id4" name="id4">4   Building luabind</a></li>
<li><a class="reference" href="#basic-usage" id="id5" name="id5">5   Basic usage</a><ul class="auto-toc">
<li><a class="reference" href="#hello-world" id="id6" name="id6">5.1   Hello world</a></li>
</ul>
</li>
<li><a class="reference" href="#scopes" id="id7" name="id7">6   Scopes</a></li>
<li><a class="reference" href="#binding-functions-to-lua" id="id8" name="id8">7   Binding functions to lua</a><ul class="auto-toc">
<li><a class="reference" href="#overloaded-functions" id="id9" name="id9">7.1   Overloaded functions</a></li>
<li><a class="reference" href="#signature-matching" id="id10" name="id10">7.2   Signature matching</a></li>
<li><a class="reference" href="#calling-lua-functions" id="id11" name="id11">7.3   Calling lua functions</a></li>
<li><a class="reference" href="#using-lua-threads" id="id12" name="id12">7.4   Using lua threads</a></li>
</ul>
</li>
<li><a class="reference" href="#binding-classes-to-lua" id="id13" name="id13">8   Binding classes to lua</a><ul class="auto-toc">
<li><a class="reference" href="#properties" id="id14" name="id14">8.1   Properties</a></li>
<li><a class="reference" href="#enums" id="id15" name="id15">8.2   Enums</a></li>
<li><a class="reference" href="#operators" id="id16" name="id16">8.3   Operators</a></li>
<li><a class="reference" href="#nested-scopes-and-static-functions" id="id17" name="id17">8.4   Nested scopes and static functions</a></li>
<li><a class="reference" href="#derived-classes" id="id18" name="id18">8.5   Derived classes</a></li>
<li><a class="reference" href="#smart-pointers" id="id19" name="id19">8.6   Smart pointers</a></li>
</ul>
</li>
<li><a class="reference" href="#object" id="id20" name="id20">9   Object</a><ul class="auto-toc">
<li><a class="reference" href="#iterators" id="id21" name="id21">9.1   Iterators</a></li>
<li><a class="reference" href="#related-functions" id="id22" name="id22">9.2   Related functions</a></li>
<li><a class="reference" href="#functor" id="id23" name="id23">9.3   Functor</a></li>
</ul>
</li>
<li><a class="reference" href="#defining-classes-in-lua" id="id24" name="id24">10   Defining classes in lua</a><ul class="auto-toc">
<li><a class="reference" href="#deriving-in-lua" id="id25" name="id25">10.1   Deriving in lua</a></li>
<li><a class="reference" href="#overloading-operators" id="id26" name="id26">10.2   Overloading operators</a></li>
<li><a class="reference" href="#finalizers" id="id27" name="id27">10.3   Finalizers</a></li>
</ul>
</li>
<li><a class="reference" href="#exceptions" id="id28" name="id28">11   Exceptions</a></li>
<li><a class="reference" href="#policies" id="id29" name="id29">12   Policies</a><ul class="auto-toc">
<li><a class="reference" href="#copy" id="id30" name="id30">12.1   Copy</a></li>
<li><a class="reference" href="#adopt" id="id31" name="id31">12.2   Adopt</a></li>
<li><a class="reference" href="#dependency" id="id32" name="id32">12.3   Dependency</a></li>
<li><a class="reference" href="#return-reference-to" id="id33" name="id33">12.4   Return reference to</a></li>
<li><a class="reference" href="#out-value" id="id34" name="id34">12.5   Out value</a></li>
<li><a class="reference" href="#pure-out-value" id="id35" name="id35">12.6   Pure out value</a></li>
<li><a class="reference" href="#discard-result" id="id36" name="id36">12.7   Discard result</a></li>
<li><a class="reference" href="#return-stl-iterator" id="id37" name="id37">12.8   Return STL iterator</a></li>
<li><a class="reference" href="#yield" id="id38" name="id38">12.9   Yield</a></li>
</ul>
</li>
<li><a class="reference" href="#splitting-up-the-registration" id="id39" name="id39">13   Splitting up the registration</a></li>
<li><a class="reference" href="#configuration" id="id40" name="id40">14   Configuration</a><ul class="auto-toc">
<li><a class="reference" href="#build-options" id="id41" name="id41">14.1   Build options</a></li>
</ul>
</li>
<li><a class="reference" href="#implementation-notes" id="id42" name="id42">15   Implementation notes</a></li>
<li><a class="reference" href="#error-messages" id="id43" name="id43">16   Error messages</a></li>
<li><a class="reference" href="#faq" id="id44" name="id44">17   FAQ</a></li>
<li><a class="reference" href="#known-issues" id="id45" name="id45">18   Known issues</a></li>
<li><a class="reference" href="#acknowledgments" id="id46" name="id46">19   Acknowledgments</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id1" name="introduction">1   Introduction</a></h1>
<p>Luabind is a library that helps you create bindings between C++ and lua. It has
the ability to expose functions and classes, written in C++, to lua. It will
also supply the functionality to define classes in lua and let them derive from
other lua classes or C++ classes. Lua classes can override virtual functions
from their C++ base classes. It is written towards lua 5.0, and does not work
with lua 4.</p>
<p>It is implemented utilizing template meta programming. That means that you
don't need an extra preprocess pass to compile your project (it is done by the
compiler). It also means you don't (usually) have to know the exact signature of
each function you register, since the library will generate code depending on
the compile-time type of the function (which includes the signature). The main
drawback of this approach is that the compilation time will increase for the
file that does the registration, it is therefore recommended that you register
everything in the same cpp-file.</p>
<p>luabind is released under the terms of the <a class="reference" href="http://www.opensource.org/licenses/mit-license.php">MIT license</a>.</p>
<p>We are very interested in hearing about projects that use luabind, please let
us know about your project.</p>
</div>
<div class="section" id="features">
<h1><a class="toc-backref" href="#id2" name="features">2   Features</a></h1>
<p>Luabind supports:</p>
<blockquote>
<ul class="simple">
<li>Overloaded free functions</li>
<li>C++ classes in lua</li>
<li>Overloaded member functions</li>
<li>Operators</li>
<li>Properties</li>
<li>Enums</li>
<li>Lua functions in C++</li>
<li>Lua classes in C++</li>
<li>Lua classes (single inheritance)</li>
<li>Derives from lua or C++ classes</li>
<li>O verride virtual functions from C++ classes</li>
<li>Implicit casts between registered types</li>
<li>Best match signature matching</li>
<li>Return value policies and parameter policies</li>
</ul>
</blockquote>
</div>
<div class="section" id="portability">
<h1><a class="toc-backref" href="#id3" name="portability">3   Portability</a></h1>
<p>Luabind has been tested to work on the following compilers:</p>
<blockquote>
<ul class="simple">
<li>Visual Studio 7.1</li>
<li>Visual Studio 7.0</li>
<li>Visual Studio 6.0 (sp 5)</li>
<li>GCC 2.95.3 (cygwin)</li>
<li>GCC 3.2 (Debian-x86)</li>
<li>GCC 3.3.1 (cygwin)</li>
</ul>
</blockquote>
<p>It has been confirmed not to work with:</p>
<blockquote>
<ul class="simple">
<li>GCC 2.95.2 (SunOS 5.8)</li>
<li>GCC 3.0.4 (Debian-x86)</li>
<li>Intel C++ 6.0 (Windows)</li>
</ul>
</blockquote>
<p>Strange behaviors:</p>
<blockquote>
<ul class="simple">
<li>GCC 2.95.4 (Debian-x86) luabind builds, but not testsuit</li>
<li>GCC 3.1 (SunOS 5.8) luabind builds but testsuit gives segmentation fault</li>
</ul>
</blockquote>
<p>Metrowerks 8.3 (Windows) compiles but fails the const-test. This 
means that const member functions are treated as non-const member 
functions.</p>
<p>If you have tried luabind with a compiler not listed here, let us know 
your result with it.</p>
</div>
<div class="section" id="building-luabind">
<h1><a class="toc-backref" href="#id4" name="building-luabind">4   Building luabind</a></h1>
<p>To keep down the compilation-time luabind is built as a library. This means you
have to either build it and lika against it, or include its source files in
your project. You also have to make sure the luabind directory is somewhere in
your compiler's include path. It requires <a class="reference" href="http://www.boost.org">Boost</a> 1.31.0 to be installed (only
boost headers). It also requires that lua is installed.</p>
<p>The official way of building luabind is with <a class="reference" href="http://www.boost.org/tools/build/v2/index_v2.html">Boost.Build V2</a>. To properly build
luabind with Boost.Build you need to set two environment variables:</p>
<dl>
<dt>BOOST_ROOT</dt>
<dd>Point this to your Boost installation.</dd>
<dt>LUA_PATH</dt>
<dd>Point this to your lua directory. The build system will assume that the
include and library files are located in <tt class="literal"><span class="pre">$(LUA_PATH)/include/</span></tt> and
<tt class="literal"><span class="pre">$(LUA_PATH)/lib/.</span></tt></dd>
</dl>
<p>For backward compatibility, there is also a makefile in the root-directory that
will build the library and the test program. If you are using a UNIX-system (or
cygwin) they will make it easy to build luabind as a static library. If you are
using Visual Studio it may be easier to include the files in the src directory
in your project.</p>
<p>When building luabind you have several options that may streamline the library
to better suit your needs. It is extremely important that your application has
the same settings as the library was built with. The available options are
found in the <a class="reference" href="#configuration">Configuration</a> section.</p>
<p>If you want to change the settings to differ from the default, it's recommended
that you define the settings on the commandline of all your files (in the
project settings in visual studio).</p>
</div>
<div class="section" id="basic-usage">
<h1><a class="toc-backref" href="#id5" name="basic-usage">5   Basic usage</a></h1>
<p>To use luabind, you must include <tt class="literal"><span class="pre">lua.h</span></tt> and luabind's main header file:</p>
<pre class="literal-block">
extern &quot;C&quot;
{
    #include &quot;lua.h&quot;
}

#include &lt;luabind/luabind.hpp&gt;
</pre>
<p>This includes support for both registering classes and functions. If you just
want to have support for functions or classes you can include
<tt class="literal"><span class="pre">luabind/function.hpp</span></tt> and <tt class="literal"><span class="pre">luabind/class.hpp</span></tt> separately:</p>
<pre class="literal-block">
#include &lt;luabind/function.hpp&gt;
#include &lt;luabind/class.hpp&gt;
</pre>
<p>The first thing you need to do is to call <tt class="literal"><span class="pre">luabind::open(lua_State*)</span></tt> which
will register the functions to create classes from lua, and initialize some
state-global structures used by luabind. If you don't call this function you
will hit asserts later in the library. There is no corresponding close function
because once a class has been registered in lua, there really isn't any good
way to remove it. Partly because any remaining instances of that class relies
on the class being there. Everything will be cleaned up when the state is
closed though.</p>
<!-- Isn't this wrong? Don't we include lua.h using lua_include.hpp ? -->
<p>Note that no luabind header will include <tt class="literal"><span class="pre">lua.h</span></tt>, this is up to you. You have
to include it before any luabind header is included.</p>
<div class="section" id="hello-world">
<h2><a class="toc-backref" href="#id6" name="hello-world">5.1   Hello world</a></h2>
<pre class="literal-block">
#include &lt;iostream&gt;
#include &lt;luabind/luabind.hpp&gt;

void greet()
{
    std::cout &lt;&lt; &quot;hello world!\n&quot;;
}

extern &quot;C&quot; int init(lua_State* L)
{
    using namespace luabind;

    open(L);

    module(L)
    [
        def(&quot;greet&quot;, &amp;greet)
    ];

    return 0;
}
</pre>
<pre class="literal-block">
Lua 5.0  Copyright (C) 1994-2003 Tecgraf, PUC-Rio
&gt; loadlib('hello_world.dll', 'init')()
&gt; greet()
Hello world!
&gt;
</pre>
</div>
</div>
<div class="section" id="scopes">
<h1><a class="toc-backref" href="#id7" name="scopes">6   Scopes</a></h1>
<p>Everything that gets registered in lua is registered in a namespace (lua
tables) or in the global scope (called module). All registrations must be
surrounded by its scope. To define a module, the <tt class="literal"><span class="pre">luabind::module</span></tt> class is
used. It is used like this:</p>
<pre class="literal-block">
module(L)
[
    // declarations
];
</pre>
<p>This will register all declared functions or classes in the global namespace in
lua. If you want to have a namespace for your module (like the standard
libraries) you can give a name to the constructor, like this:</p>
<pre class="literal-block">
module(L, &quot;my_library&quot;)
[
    // declarations
];
</pre>
<p>Here all declarations will be put in the my_library table.</p>
<p>If you want nested namespaces you can use the <tt class="literal"><span class="pre">luabind::namespace_</span></tt> class. It
works exactly as <tt class="literal"><span class="pre">luabind::module</span></tt> except that it doesn't take a lua_State*
in it's constructor. An example of its usage could look like this:</p>
<pre class="literal-block">
module(L, &quot;my_library&quot;)
[
    // declarations

    namespace_(&quot;detail&quot;)
    [
        // library-private declarations
    ]
];
</pre>
<p>As you might have figured out, the following declarations are equivalent:</p>
<pre class="literal-block">
module(L)
[
    namespace_(&quot;my_library&quot;)
    [
        // declarations
    ]

];
</pre>
<pre class="literal-block">
module(L, &quot;my_library&quot;)
[
    // declarations
];
</pre>
<p>Each declaration must be separated by a comma, like this:</p>
<pre class="literal-block">
module(L)
[
    def(&quot;f&quot;, &amp;f),
    def(&quot;g&quot;, &amp;g),
    class_&lt;A&gt;(&quot;A&quot;)
        .def(constructor&lt;int, int&gt;),
    def(&quot;h&quot;, &amp;h)
];
</pre>
<p>More about the actual declarations in the <a class="reference" href="#binding-functions-to-lua">Binding functions to lua</a> and
<a class="reference" href="#binding-classes-to-lua">Binding classes to lua</a> sections.</p>
<p>A word of caution, if you are in really bad need for performance, putting your
functions in tables will increase the lookup time.</p>
</div>
<div class="section" id="binding-functions-to-lua">
<h1><a class="toc-backref" href="#id8" name="binding-functions-to-lua">7   Binding functions to lua</a></h1>
<p>To bind functions to lua you use the function <tt class="literal"><span class="pre">luabind::def()</span></tt>. It has the
following synopsis:</p>
<pre class="literal-block">
template&lt;class F, class policies&gt;
void def(const char* name, F f, const Policies&amp;);
</pre>
<ul class="simple">
<li>name is the name the function will have within lua.</li>
<li>F is the function pointer you want to register.</li>
<li>The Policies parameter is used to describe how parameters and return values 
are treated by the function, this is an optional parameter. More on this in 
the <a class="reference" href="#policies">policies</a> section.</li>
</ul>
<p>An example usage could be if you want to register the function <tt class="literal"><span class="pre">float</span>
<span class="pre">std::sin(float)</span></tt>:</p>
<pre class="literal-block">
module(L)
[
    def(&quot;sin&quot;, &amp;std::sin)
];
</pre>
<div class="section" id="overloaded-functions">
<h2><a class="toc-backref" href="#id9" name="overloaded-functions">7.1   Overloaded functions</a></h2>
<p>If you have more than one function with the same name, and want to register
them in lua, you have to explicitly give the signature. This is to let C++ know
which function you refer to. For example, if you have two functions, <tt class="literal"><span class="pre">int</span>
<span class="pre">f(const</span> <span class="pre">char*)</span></tt> and <tt class="literal"><span class="pre">void</span> <span class="pre">f(int)</span></tt>.</p>
<pre class="literal-block">
module(L)
[
    def(&quot;f&quot;, (int(*)(const char*)) &amp;f),
    def(&quot;f&quot;, (void(*)(int)) &amp;f)
];
</pre>
</div>
<div class="section" id="signature-matching">
<h2><a class="toc-backref" href="#id10" name="signature-matching">7.2   Signature matching</a></h2>
<p>luabind will generate code that checks the lua stack to see if the values there
can match your functions' signatures. It will handle implicit typecasts between
derived classes, and it will prefer matches with the least number of implicit
casts. In a function call, if the function is overloaded and there's no
overload that match the parameters better than the other, you have an
ambiguity. This will spawn a run-time error, stating that the function call is
ambiguous. A simple example of this is to register one function that takes an
int and one that takes a float. Since lua don't distinguish between floats and
integers, both will always match.</p>
<p>Since all overloads are tested, it will always find the best match (not the
first match). This also means that it can handle situations where the only
difference in the signature is that one member function is const and the other
isn't.</p>
<div class="sidebar">
<p class="sidebar-title">Ownership transfer</p>
<p>To correctly handle ownership transfer, create_a() would need an adopt
return value policy. More on this in the <a class="reference" href="#policies">Policies</a> section.</p>
</div>
<p>For example, if the following function and class is registered:</p>
<pre class="literal-block">
struct A
{
    void f();
    void f() const;
};

const A* create_a();

struct B: A {};
struct C: B {};

void g(A*);
void g(B*);
</pre>
<p>And the following lua code is executed:</p>
<pre class="literal-block">
a1 = create_a()
a1:f() -- the const version is called

a2 = A()
a2:f() -- the non-const version is called

a = A()
b = B()
c = C()

g(a) -- calls g(A*)
g(b) -- calls g(B*)
g(c) -- calls g(B*)
</pre>
</div>
<div class="section" id="calling-lua-functions">
<h2><a class="toc-backref" href="#id11" name="calling-lua-functions">7.3   Calling lua functions</a></h2>
<p>To call a lua function, you can either use <tt class="literal"><span class="pre">call_function()</span></tt>,
<tt class="literal"><span class="pre">call_member()</span></tt>, an <tt class="literal"><span class="pre">object</span></tt> or <tt class="literal"><span class="pre">functor</span></tt>.</p>
<pre class="literal-block">
template&lt;class Ret&gt;
Ret call_function(lua_State* L, const char* name, ...)
</pre>
<p>This calls the global function called name. This function can only call global
lua functions. The ... represents a variable number of parameters that are sent
to the lua function. This function call may throw <tt class="literal"><span class="pre">luabind::error</span></tt> if the
function call fails.</p>
<p>The return value isn't actually Ret (the template parameter), but a proxy
object that will do the function call. This enables you to give policies to the
call. You do this with the operator[]. You give the policies within the
brackets, like this:</p>
<pre class="literal-block">
int ret = call_function&lt;int&gt;(
    L 
  , &quot;a_lua_function&quot;
  , new complex_class()
)[ adopt(_1) ];
</pre>
<pre class="literal-block">
template&lt;class Ret&gt;
Ret call_member(object&amp;, const char* name, ...)
</pre>
<p>This treats the given object as an instance of a class. The given name is the
name of a member function to call. The ... represents a variable number of
parameters given to the function. This function may throw <tt class="literal"><span class="pre">luabind::error</span></tt> if
the function call fails.</p>
<p>You can give policies to a member function call the same way as you do with
<tt class="literal"><span class="pre">call_function</span></tt>.</p>
</div>
<div class="section" id="using-lua-threads">
<h2><a class="toc-backref" href="#id12" name="using-lua-threads">7.4   Using lua threads</a></h2>
<p>To start a lua thread, you have to call <tt class="literal"><span class="pre">lua_resume()</span></tt>, this means that you
cannot use the previous function <tt class="literal"><span class="pre">call_function()</span></tt> to start a thread. You have
to use</p>
<pre class="literal-block">
template&lt;class Ret&gt;
Ret resume_function(lua_State* L, const char* name, ...)
</pre>
<p>and</p>
<pre class="literal-block">
template&lt;class Ret&gt;
Ret resume(lua_State* L, ...)
</pre>
<p>The first time you start the thread, you have to give it a function to execute. i.e. you
have to use <tt class="literal"><span class="pre">resume_function</span></tt>, when the lua function yeilds, it will return the first
value passed in to <tt class="literal"><span class="pre">lua_yield()</span></tt>. When you want to continue the execution, you just call
<tt class="literal"><span class="pre">resume()</span></tt> on your <tt class="literal"><span class="pre">lua_State</span></tt>, since it's already executing a function, you don't pass
it one. The parameters to <tt class="literal"><span class="pre">resume()</span></tt> will be returned by <tt class="literal"><span class="pre">yield()</span></tt> on the lua side.</p>
<p>For yielding C++-functions (without the support of passing data back and forth between the
lua side and the c++ side), you can use the <a class="reference" href="#yield">Yield</a> policy.</p>
</div>
</div>
<div class="section" id="binding-classes-to-lua">
<h1><a class="toc-backref" href="#id13" name="binding-classes-to-lua">8   Binding classes to lua</a></h1>
<p>To register classes you use a class called <tt class="literal"><span class="pre">class_</span></tt>. Its name is supposed to
resemble the C++ keyword, to make it look more intuitive. It has an overloaded
member function <tt class="literal"><span class="pre">def()</span></tt> that is used to register member functions, operators,
constructors, enums and properties on the class. It will return its
this-pointer, to let you register more members directly.</p>
<p>Let's start with a simple example. Consider the following C++ class:</p>
<pre class="literal-block">
class testclass
{
public:
    testclass(const std::string&amp; s): m_string(s) {}
    void print_string() { std::cout &lt;&lt; m_string &lt;&lt; &quot;\n&quot;; }

private:
    std::string m_string;
};
</pre>
<p>To register it with a lua environment, write as follows (assuming you are using
namespace luabind):</p>
<pre class="literal-block">
module(L)
[
    class_&lt;testclass&gt;(&quot;testclass&quot;)
        .def(constructor&lt;const std::string&amp;&gt;())
        .def(&quot;print_string&quot;, &amp;testclass::print_string)
];
</pre>
<p>This will register the class with the name testclass and constructor that takes
a string as argument and one member function with the name <tt class="literal"><span class="pre">print_string</span></tt>.</p>
<pre class="literal-block">
Lua 5.0  Copyright (C) 1994-2003 Tecgraf, PUC-Rio
&gt; a = testclass('a string')
&gt; a:print_string()
a string
</pre>
<p>It is also possible to register free functions as member functions. The
requirement on the function is that it takes a pointer, const pointer,
reference or const reference to the class type as the first parameter. The rest
of the parameters are the ones that are visible in lua, while the object
pointer is given as the first parameter. If we have the following C++ code:</p>
<pre class="literal-block">
struct A
{
    int a;
};

int plus(A* o, int v) { return o-&gt;a + v; }
</pre>
<p>You can register <tt class="literal"><span class="pre">plus()</span></tt> as if it was a member function of A like this:</p>
<pre class="literal-block">
class_&lt;A&gt;(&quot;A&quot;)
    .def(&quot;plus&quot;, &amp;plus)
</pre>
<p><tt class="literal"><span class="pre">plus()</span></tt> can now be called as a member function on A with one parameter, int.
If the object pointer parameter is const, the function will act as if it was a
const member function (it can be called on const objects).</p>
<div class="section" id="properties">
<h2><a class="toc-backref" href="#id14" name="properties">8.1   Properties</a></h2>
<p>To register a global data member with a class is easily done. Consider the
following class:</p>
<pre class="literal-block">
struct A
{
    int a;
};
</pre>
<p>This class is registered like this:</p>
<pre class="literal-block">
module(L)
[
    class_&lt;A&gt;(&quot;A&quot;)
        .def_readwrite(&quot;a&quot;, &amp;A::a)
];
</pre>
<p>This gives read and write access to the member variable <tt class="literal"><span class="pre">A::a</span></tt>. It is also
possible to register attributes with read-only access:</p>
<pre class="literal-block">
module(L)
[
    class_&lt;A&gt;(&quot;A&quot;)
    .def_readonly(&quot;a&quot;, &amp;A::a)
];
</pre>
<p>You can also register getter and setter functions and make them look as if they
were a public data member. Consider the following class:</p>
<pre class="literal-block">
class A
{
public:
    void set_a(int x) { a = x; }
    int get_a() const { return a; }

private:
    int a;
};
</pre>
<p>It can be registered as if it had a public data member a like this:</p>
<pre class="literal-block">
class_&lt;A&gt;(&quot;A&quot;)
    .property(&quot;a&quot;, &amp;A::get_a, &amp;A::set_a)
</pre>
<p>This way the <tt class="literal"><span class="pre">get_a()</span></tt> and <tt class="literal"><span class="pre">set_a()</span></tt> functions will be called instead of
just writing  to the data member. If you want to make it read only you can just
omit the last parameter.</p>
</div>
<div class="section" id="enums">
<h2><a class="toc-backref" href="#id15" name="enums">8.2   Enums</a></h2>
<p>If your class contains enumerated constants (enums), you can register them as
well to make them available in lua. Note that they will not be type safe, all
enums are integers in lua, and all functions that takes an enum, will accept
any integer. You register them like this:</p>
<pre class="literal-block">
module(L)
[
    class_&lt;A&gt;(&quot;A&quot;)
        .enum_(&quot;constants&quot;)
        [
            value(&quot;my_enum&quot;, 4),
            value(&quot;my_2nd_enum&quot;, 7),
            value(&quot;another_enum&quot;, 6)
        ]
];
</pre>
<p>In lua they are accessed like any data member, except that they are read-only
and reached on the class itself rather than on an instance of the class.</p>
<pre class="literal-block">
Lua 5.0  Copyright (C) 1994-2003 Tecgraf, PUC-Rio
&gt; print(A.my_enum)
4
&gt; print(A.another_enum)
6
</pre>
</div>
<div class="section" id="operators">
<h2><a class="toc-backref" href="#id16" name="operators">8.3   Operators</a></h2>
<p>The mechanism for registering operators on your class is pretty simple. You use
a global name <tt class="literal"><span class="pre">luabind::self</span></tt> to refer to the class itself and then you just
write the operator expression inside the <tt class="literal"><span class="pre">def()</span></tt> call. This class:</p>
<pre class="literal-block">
struct vec
{
    vec operator+(int s);
};
</pre>
<p>Is registered like this:</p>
<pre class="literal-block">
module(L)
[
    class_&lt;vec&gt;(&quot;vec&quot;)
        .def(self + int())
];
</pre>
<p>This will work regardless if your plus operator is defined inside your class or
as a free function.</p>
<p>If you operator is const (or, when defined as a free function, takes a const
reference to the class itself) you have to use <tt class="literal"><span class="pre">const_self</span></tt> instead of
<tt class="literal"><span class="pre">self</span></tt>. Like this:</p>
<pre class="literal-block">
module(L)
[
    class_&lt;vec&gt;(&quot;vec&quot;)
        .def(const_self + int())
];
</pre>
<p>The operators supported are those available in lua:</p>
<blockquote>
<ul class="simple">
<li>+</li>
<li>-</li>
<li>*</li>
<li>/</li>
</ul>
<!-- more -->
</blockquote>
<p>This means, no in-place operators. The equality operator (==) has a little
hatch, it will not be called if the references are equal. This means that the
== operator has to do pretty much what's it's expected to do.</p>
<p>In the above example the other operand type is instantiated by writing
<tt class="literal"><span class="pre">int()</span></tt>. If the operand type is a complex type that cannot easily be
instantiated you can wrap the type in a class called <tt class="literal"><span class="pre">other&lt;&gt;</span></tt>. For example:</p>
<p>To register this class, we don't want to instantiate a string just to register
the operator.</p>
<pre class="literal-block">
struct vec
{
    vec operator+(std::string);
};
</pre>
<p>Instead we use the other <tt class="literal"><span class="pre">wrapper</span></tt> like this:</p>
<pre class="literal-block">
module(L)
[
    class_&lt;vec&gt;(&quot;vec&quot;)
        .def(self + other&lt;std::string&gt;())
];
</pre>
<p>To register an application operator:</p>
<pre class="literal-block">
module(L)
[
    class_&lt;vec&gt;(&quot;vec&quot;)
        .def( self(int()) )
];
</pre>
<p>There's one special operator. In lua it's called <tt class="literal"><span class="pre">__tostring</span></tt>, it's not
really an operator. It is used for converting objects to strings in a standard
way in lua. If you register this functionality, you will be able to use the lua
standard function <tt class="literal"><span class="pre">tostring()</span></tt> for converting you object to a string.</p>
<p>To implement this operator in C++ you should supply an <tt class="literal"><span class="pre">operator&lt;&lt;</span></tt> for
ostream. Like this example:</p>
<pre class="literal-block">
class number {};
std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, number&amp;);

...

module(L)
[
    class_&lt;number&gt;(&quot;number&quot;)
        .def(tostring(self))
];
</pre>
</div>
<div class="section" id="nested-scopes-and-static-functions">
<h2><a class="toc-backref" href="#id17" name="nested-scopes-and-static-functions">8.4   Nested scopes and static functions</a></h2>
<p>It is possible to add nested scopes to a class. This is useful when you need 
to wrap a nested class, or a static function.</p>
<pre class="literal-block">
class_&lt;foo&gt;(&quot;foo&quot;)
    .def(constructor&lt;&gt;()
    ...
    .scope
    [
        class_&lt;inner&gt;(&quot;nested&quot;),
        def(&quot;f&quot;, &amp;f)
    ];
</pre>
<p>It's also possible to add namespaces to classes using the same syntax.</p>
</div>
<div class="section" id="derived-classes">
<h2><a class="toc-backref" href="#id18" name="derived-classes">8.5   Derived classes</a></h2>
<p>If you want to register classes that derives from other classes, you can
specify a template parameter <tt class="literal"><span class="pre">bases&lt;&gt;</span></tt> to the <tt class="literal"><span class="pre">class_</span></tt> instantiation. The
following hierarchy:</p>
<pre class="literal-block">
struct A {};
struct B : A {};
</pre>
<p>Would be registered like this:</p>
<pre class="literal-block">
module(L)
[
    class_&lt;A&gt;(&quot;A&quot;),
    class_&lt;B, A&gt;(&quot;B&quot;)
];
</pre>
<p>If you have multiple inheritance you can specify more than one base. If B would
also derive from a class C, it would be registered like this:</p>
<pre class="literal-block">
module(L)
[
    class_&lt;B, bases&lt;A, C&gt; &gt;(&quot;B&quot;)
];
</pre>
<p>Note that you can omit <tt class="literal"><span class="pre">bases&lt;&gt;</span></tt> when using single inheritance.</p>
<div class="note">
<p class="admonition-title">Note</p>
If you don't specify that classes derive from each other, luabind will not
be able to implicitly cast pointers between the types.</div>
</div>
<div class="section" id="smart-pointers">
<h2><a class="toc-backref" href="#id19" name="smart-pointers">8.6   Smart pointers</a></h2>
<p>When you register a class you can tell luabind that all instances of that class
should be held by some kind of smart pointer (boost::shared_ptr for instance).
You do this by giving the holder type as an extra template parameter to
the``class_``your constructing, like this:</p>
<pre class="literal-block">
module(L)
[
    class_&lt;A, boost::shared_ptr&lt;A&gt; &gt;(&quot;A&quot;)
];
</pre>
<p>You also have to supply two functions for your smart pointer. One that returns
the type of const version of the smart pointer type (boost::shared_ptr&lt;const A&gt;
in this case). And one function that extracts the raw pointer from the smart
pointer. The first function is needed because luabind has to allow the
non-const -&gt; conversion when passing values from lua to C++. The second
function is needed when lua calls member functions on held types, the this
pointer must be a raw pointer, it is also needed to allow the smart_pointer -&gt;
raw_pointer conversion from lua to C++. They look like this:</p>
<pre class="literal-block">
namespace luabind {

    template&lt;class T&gt;
    T* get_pointer(boost::shared_ptr&lt;T&gt;&amp; p) 
    { 
        return p.get(); 
    }

    template&lt;class A&gt;
    boost::shared_ptr&lt;const A&gt;* 
    get_const_holder(boost::shared_ptr&lt;A&gt;*)
    {
        return 0;
    }
}
</pre>
<p>The conversion that works are (given that B is a base class of A):</p>
<table border class="table">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th colspan="2">From lua to C++</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>holder_type&lt;A&gt;</td>
<td>A*</td>
</tr>
<tr><td>holder_type&lt;A&gt;</td>
<td>A*</td>
</tr>
<tr><td>holder_type&lt;A&gt;</td>
<td>const A*</td>
</tr>
<tr><td>holder_type&lt;A&gt;</td>
<td>const B*</td>
</tr>
<tr><td>holder_type&lt;A&gt;</td>
<td>holder_type&lt;A&gt;</td>
</tr>
<tr><td>holder_type&lt;A&gt;</td>
<td>holder_type&lt;const A&gt;</td>
</tr>
<tr><td>holder_type&lt;const A&gt;</td>
<td>const A*</td>
</tr>
<tr><td>holder_type&lt;const A&gt;</td>
<td>const B*</td>
</tr>
<tr><td>holder_type&lt;const A&gt;</td>
<td>holder_type&lt;const A&gt;</td>
</tr>
</tbody>
</table>
<table border class="table">
<colgroup>
<col width="56%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr><th colspan="2">From C++ to lua</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>holder_type&lt;A&gt;</td>
<td>holder_type&lt;A&gt;</td>
</tr>
<tr><td>holder_type&lt;const A&gt;</td>
<td>holder_type&lt;const A&gt;</td>
</tr>
<tr><td>const holder_type&lt;A&gt;&amp;</td>
<td>holder_type&lt;A&gt;</td>
</tr>
<tr><td>const holder_type&lt;const A&gt;&amp;</td>
<td>holder_type&lt;const A&gt;</td>
</tr>
</tbody>
</table>
<p>When using a holder type, it can be useful to know if the pointer is valid. For
example when using std::auto_ptr, the holder will be invalidated when passed as
a parameter to a function. For this purpose there is a member of all object
instances in luabind: <tt class="literal"><span class="pre">__ok</span></tt>.</p>
<pre class="literal-block">
struct test {};
void f(std::auto_ptr&lt;test&gt;);

module(L)
[
    class_&lt;test&gt;(&quot;test&quot;)
        .def(constructor&lt;&gt;()),

    def(&quot;f&quot;, &amp;f)
];
</pre>
<pre class="literal-block">
Lua 5.0  Copyright (C) 1994-2003 Tecgraf, PUC-Rio
&gt; a = test()
&gt; f(a)
&gt; print a.__ok
false
</pre>
</div>
</div>
<div class="section" id="object">
<h1><a class="toc-backref" href="#id20" name="object">9   Object</a></h1>
<p>Since functions have to be able to take lua values (of variable type) we need a
wrapper around them. This wrapper is called <tt class="literal"><span class="pre">luabind::object</span></tt>. If the
function you register takes an object, it will match any lua value. To use it,
you need to include <tt class="literal"><span class="pre">luabind/object.hpp</span></tt>. The object class has the following
synopsis:</p>
<pre class="literal-block">
class object
{
public:
    class iterator;
    class raw_iterator;
    class array_iterator;

    template&lt;class T&gt;
    object(lua_State*, const T&amp; value);
    object(const object&amp;);
    object(lua_State*);
    object();

    ~object();
    
    iterator begin() const;
    iterator end() const;
    raw_iterator raw_begin() const;
    raw_iterator raw_end() const;
    array_iterator abegin() const;
    array_iterator aend() const;

    void set();
    lua_State* lua_state() const;
    void pushvalue() const;
    bool is_valid() const;
    operator safe_bool_type() const;

    template&lt;class Key&gt;
    &lt;implementation-defined&gt; operator[](const Key&amp;);

    template&lt;class Key&gt;
    object at(const Key&amp;) const;

    template&lt;class Key&gt;
    object raw_at(const Key&amp;) const;

    template&lt;class T&gt;
    object&amp; operator=(const T&amp;);
    object&amp; operator=(const object&amp;);

    template&lt;class T&gt;
    bool operator==(const T&amp;) const;
    bool operator==(const object&amp;) const;
    bool operator&lt;(const object&amp;) const;
    bool operator&lt;=(const object&amp;) const;
    bool operator&gt;(const object&amp;) const;
    bool operator&gt;=(const object&amp;) const;
    bool operator!=(const object&amp;) const;

    void swap(object&amp;);
    int type() const;

    &lt;implementation-defined&gt; operator()();
    
    template&lt;class A0&gt;
    &lt;implementation-defined&gt; operator()(const A0&amp; a0);

    template&lt;class A0, class A1&gt;
    &lt;implementation-defined&gt; operator()(const A0&amp; a0, const A1&amp; a1);

    /* ... */
    
};
</pre>
<p>When you have a lua object, you can assign it a new value with the assignment
operator (=). When you do this, the <tt class="literal"><span class="pre">default_policy</span></tt> will be used to make the
conversion from C++ value to lua. If your <tt class="literal"><span class="pre">luabind::object</span></tt> is a table you
can access its members through the operator[] or the iterators. The value
returned from the operator[] is a proxy object that can be used both for
reading and writing values into the table (using operator=). Note that it is
impossible to know if a lua value is indexable or not (lua_gettable doesn't
fail, it succeeds or crashes). This means that if you're trying to index
something that cannot be indexed, you're on your own. Lua will call its
<tt class="literal"><span class="pre">panic()</span></tt> function (you can define your own panic function using
lua_setpanicf). The <tt class="literal"><span class="pre">at()</span></tt> and <tt class="literal"><span class="pre">raw_at()</span></tt> functions returns the value at
the given table position (like operator[] but only for reading).</p>
<p>The ordinary <tt class="literal"><span class="pre">object::iterator</span></tt> uses lua_gettable to extract the values from
the table, the standard way that will invoke metamethods if any. The
<tt class="literal"><span class="pre">object::raw_iterator</span></tt> uses lua_rawget and <tt class="literal"><span class="pre">object::array_iterator</span></tt> uses
lua_rawgeti. The latter will only iterate over numberical keys starting at 1
and continue until the first nil value.</p>
<p>The <tt class="literal"><span class="pre">lua_state()</span></tt> function returns the lua state where this object is stored.
If you want to manipulate the object with lua functions directly you can push
it onto the lua stack by calling <tt class="literal"><span class="pre">pushvalue()</span></tt>. And set the object's value by
calling <tt class="literal"><span class="pre">set()</span></tt>, which will pop the top value from the lua stack and assign
it to the object.</p>
<p>The operator== will call lua_equal() on the operands and return its result.</p>
<p>The <tt class="literal"><span class="pre">type()</span></tt> member function will return the lua type of the object. It will
return the same values as lua_type().</p>
<p>The <tt class="literal"><span class="pre">is_valid()</span></tt> function tells you whether the object has been initialized
or not. When created with its default constructor, objects are invalid. To make
an object valid, you can assign it a value. If you want to invalidate an object
you can simply assign it an invalid object.</p>
<!-- So what? implementation detail, leave out of docs
isn't really an implicit cast to bool, but an implicit cast
to a member pointer, since member pointers don't have any arithmetic operators
on them (which can cause hard to find errors). The functionality of the cast
operator -->
<p>The <tt class="literal"><span class="pre">operator</span> <span class="pre">safe_bool_type()</span></tt> is equivalent to <tt class="literal"><span class="pre">is_valid()</span></tt>. This means
that these snippets are equivalent:</p>
<pre class="literal-block">
object o;
// ...
if (o)
{
    // ...
}

...

object o;
// ...
if (o.is_valid())
{
    // ...
}
</pre>
<p>The application operator will call the value as if it was a function. You can
give it any number of parameters (currently the <tt class="literal"><span class="pre">default_policy</span></tt> will be used
for the conversion). The returned object refers to the return value (currently
only one return value is supported). This operator may throw <tt class="literal"><span class="pre">luabind::error</span></tt>
if the function call fails. If you want to specify policies to your function
call, you can use index-operator (operator[]) on the function call, and give
the policies within the [ and ]. Like this:</p>
<pre class="literal-block">
my_function_object(
    2
  , 8
  , new my_complex_structure(6)
) [ adopt(_3) ];
</pre>
<p>This tells luabind to make lua adopt the ownership and responsibility for the
pointer passed in to the lua-function.</p>
<p>It's important that all instances of object have been destructed by the time
the lua state is closed. The object will keep a pointer to the lua state and
release its lua object in its destructor.</p>
<p>Here's an example of how a function can use a table:</p>
<pre class="literal-block">
void my_function(const object&amp; table)
{
    if (table.type() == LUA_TTABLE)
    {
        table[&quot;time&quot;] = std::clock();
        table[&quot;name&quot;] = std::rand() &lt; 500 ? &quot;unusual&quot; : &quot;usual&quot;;

        std::cout &lt;&lt; object_cast&lt;std::string&gt;(table[5]) &lt;&lt; &quot;\n&quot;;
    }
}
</pre>
<p>If you take a <tt class="literal"><span class="pre">luabind::object</span></tt> as a parameter to a function, any lua value
will match that parameter. That's why we have to make sure it's a table before
we index into it.</p>
<div class="section" id="iterators">
<h2><a class="toc-backref" href="#id21" name="iterators">9.1   Iterators</a></h2>
<p>The iterators, that are returned by <tt class="literal"><span class="pre">begin()</span> <span class="pre">and</span> <span class="pre">``end()</span></tt> (and their
variants) are (almost) models of the ForwardIterator concept. The exception
is that post increment doesn't exist on them.</p>
<p>They look like this:</p>
<pre class="literal-block">
class object::iterator
{
    iterator();
    iterator(const iterator&amp;);

    iterator&amp; operator++();
    bool operator!=(const iterator&amp;) const;
    iterator&amp; operator=(const iterator&amp;);

    object key() const;

    implementation-defined operator*();
};
</pre>
<p>The implementation defined return value from the dereference operator is a
proxy object that can be used as if it was an object, it can also be used to
assign the specific table entry with a new value. If you want to assign a value
to an entry pointed to by an iterator, just use the assignment operator on the
dereferenced iterator:</p>
<pre class="literal-block">
*iter = 5;
</pre>
<p>The <tt class="literal"><span class="pre">key()</span></tt> member returns the key used by the iterator when indexing the
associated lua table.</p>
</div>
<div class="section" id="related-functions">
<h2><a class="toc-backref" href="#id22" name="related-functions">9.2   Related functions</a></h2>
<p>There are a couple of functions related to objects and tables.</p>
<pre class="literal-block">
T object_cast&lt;T&gt;(const object&amp;);
T object_cast&lt;T&gt;(const object&amp;, const Policies&amp;);

boost::optional&lt;T&gt; 
object_cast_nothrow&lt;T&gt;(const object&amp;);

boost::optional&lt;T&gt;  
object_cast_nothrow&lt;T&gt;(const object&amp;, const Policies&amp;);
</pre>
</div>
<div class="section" id="functor">
<h2><a class="toc-backref" href="#id23" name="functor">9.3   Functor</a></h2>
<p>The <tt class="literal"><span class="pre">functor</span></tt> class is similar to object, with the exception that it can only
be used to store functions. If you take it as a parameter, it will only match
functions.</p>
<p>To use it you need to include its header:</p>
<pre class="literal-block">
#include &lt;luabind/functor.hpp&gt;
</pre>
<p>It takes one template parameter, the return value of the lua function it
represents. Currently the functor can have at most one return value (unlike lua
functions). It has the following synopsis:</p>
<pre class="literal-block">
template&lt;class Ret&gt;
class functor
{
public:

    functor(lua_State*, const char* name);
    functor(const functor&amp;);

    ~functor();
    
    bool is_valid() const;
    operator safe_bool_type() const;
    void reset();

    lua_State* lua_state() const;
    void pushvalue() const;
    
    bool operator==(const functor&lt;Ret&gt;&amp;);
    bool operator!=(const functor&lt;Ret&gt;&amp;);
    
    &lt;implementation-defined&gt; operator()() const;
    
    template&lt;class A0&gt;
    &lt;implementation-defined&gt; operator()(const A0&amp;) const;

    template&lt;class A0, class A1&gt;
    &lt;implementation-defined&gt; operator()(const A0&amp;, const A1&amp;) const;

    /* ... */
};
</pre>
<p>The application operator takes any parameters. The parameters are converted
into lua and the function is called. The return value will act as if it was the
type Ret, with the exception that you can use the return value to give policies
to the call. You do this the same way as you do with objects, using the
operator[], and giving the policies inside the brackets.</p>
<p>The <tt class="literal"><span class="pre">is_valid()</span></tt> function works just like the one on object, it tells you if
the functor has been assigned with a valid lua function. The <tt class="literal"><span class="pre">operator</span>
<span class="pre">safe_bool_type()</span></tt> is an alias for this member function and also works just as
the one found in object.</p>
<p>For example, if you have the following lua function:</p>
<pre class="literal-block">
function f(a, b)
    return a + b
end
</pre>
<p>You can expose it to C++ like this:</p>
<pre class="literal-block">
functor&lt;int&gt; f(L, &quot;f&quot;);

std::cout &lt;&lt; f(3, 5) &lt;&lt; &quot;\n&quot;;
</pre>
<p>This will print out the sum of 3 and 5. Note that you can pass any parameters
to the application operator of <tt class="literal"><span class="pre">luabind::functor</span></tt>, this is because lua
doesn't have signatures for its functions. All lua functions take any number of
parameters of any type.</p>
<p>If we have a C++ function that takes a <tt class="literal"><span class="pre">luabind::functor</span></tt> and registers it,
it will accept lua functions passed to it. This enables us to expose APIs that
requires you to register callbacks. For example, if your C++ API looks like
this:</p>
<pre class="literal-block">
void set_callback(void(*)(int, int));
</pre>
<p>And you want to expose it to lua, you have to wrap the call to the lua 
function inside a real C++ function, like this:</p>
<pre class="literal-block">
functor&lt;void&gt; lua_callback;

void callback_wrapper(int a, int b)
{
    lua_callback(a, b);
}

void set_callback_wrapper(const functor&lt;void&gt;&amp; f)
{
    lua_callback = f;
    set_callback(&amp;callback_wrapper);
}
</pre>
<p>And then register <tt class="literal"><span class="pre">set_callback_wrapper</span></tt> instead of registering
<tt class="literal"><span class="pre">set_callback</span></tt>. This will have the effect that when one tries to register the
callback from lua, your <tt class="literal"><span class="pre">set_callback_wrapper</span></tt> will be called instead and
first set the lua functor to the given function. It will then call the real
<tt class="literal"><span class="pre">set_callback</span></tt> with the <tt class="literal"><span class="pre">callback_wrapper</span></tt>. The <tt class="literal"><span class="pre">callback_wrapper</span></tt> will
be called whenever the callback should be called, and it will simply call the
lua function that we registered.</p>
<p>You can also use <tt class="literal"><span class="pre">object_cast</span></tt> to cast an object to a functor.</p>
<p><tt class="literal"><span class="pre">reset</span></tt> on <tt class="literal"><span class="pre">functor</span></tt> will invalidate the functor (and remove any references
to its lua value). If the functor object has longer lifetime than the lua state
(e.g. if it's a global).</p>
</div>
</div>
<div class="section" id="defining-classes-in-lua">
<h1><a class="toc-backref" href="#id24" name="defining-classes-in-lua">10   Defining classes in lua</a></h1>
<p>In addition to binding C++ functions and classes with lua, luabind also provide
an OO-system in lua.</p>
<pre class="literal-block">
class 'lua_testclass'

function lua_testclass:__init(name)
    self.name = name
end

function lua_testclass:print()
    print(self.name)
end

a = lua_testclass('example')
a:print()
</pre>
<p>Inheritance can be used between lua-classes:</p>
<pre class="literal-block">
class 'derived' (lua_testclass)

function derived:__init() super('derived name')
end

function derived:print()
    print('Derived:print() -&gt; ')
    lua_testclass.print(self)
end
</pre>
<p>Here the <tt class="literal"><span class="pre">super</span></tt> keyword is used in the constructor to initialize the base
class. The user is required to call <tt class="literal"><span class="pre">super</span></tt> first in the constructor.</p>
<p>As you can see in this example, you can call the base class member functions.
You can find all member functions in the base class, but you will have to give
the this-pointer (<tt class="literal"><span class="pre">self</span></tt>) as first argument.</p>
<div class="section" id="deriving-in-lua">
<h2><a class="toc-backref" href="#id25" name="deriving-in-lua">10.1   Deriving in lua</a></h2>
<p>It is also possible to derive lua classes from C++ classes, and override
virtual functions with lua functions. To do this we have to create a wrapper
class for our C++ base class. This is the class that will hold the lua object
when we instantiate a lua class.</p>
<p>The wrapper class has to provide the same constructors as the base class, with
the addition of one extra parameter: <tt class="literal"><span class="pre">luabind::weak_ref</span></tt>. This is the reference
to the lua object that should be held by the wrapper, and should be stored in a
member variable as done in the sample below.</p>
<pre class="literal-block">
class base
{
public:
    base(const char* s)
    { std::cout &lt;&lt; s &lt;&lt; &quot;\n&quot;; }

    virtual void f(int a) 
    { std::cout &lt;&lt; &quot;f(&quot; &lt;&lt; a &lt;&lt; &quot;)\n&quot;; }
};

struct base_wrapper : base
{
    weak_ref self;
    base_wrapper(weak_ref self_, const char* s)
        : base(s), self(self_) 
    {}

    virtual void f(int a) 
    { 
        call_member&lt;void&gt;(self, &quot;f&quot;, a); 
    }

    static void f_static(base* ptr, int a)
    {
        return ptr-&gt;base::f(a);
    }
};

...

module(L)
[
    class_&lt;base, base_wrapper&gt;(&quot;base&quot;)
        .def(constructor&lt;const char*&gt;())
        .def(&quot;f&quot;, &amp;base_wrapper::f_static)
];  
</pre>
<p>Note that if you have both base classes and a base class wrapper, you must give
both bases and the base class wrapper type as template parameter to 
´´class_´´. The order in which you specify them is not important.</p>
<p>If we didn't have a class wrapper, it would not be possible to pass a lua class
back to C++. Since the entry points of the virtual functions would still point
to the C++ base class, and not to the functions defined in lua. That's why we
need one function that calls the base class' real function (used if the lua
class doesn't redefine it) and one virtual function that dispatches the call
into luabind, to allow it to select if a lua function should be called, or if
the original function should be called. If you don't intend to derive from a
C++ class, or if it doesn't have any virtual member functions, you can register
it without a class wrapper.</p>
<p>You don't need to have a class wrapper in order to derive from a class, but if
it has virtual functions you may have silent errors.</p>
<!-- Unnecessary? The rule of thumb is: 
If your class has virtual functions, create a wrapper type, if it doesn't
don't create a wrapper type. -->
</div>
<div class="section" id="overloading-operators">
<h2><a class="toc-backref" href="#id26" name="overloading-operators">10.2   Overloading operators</a></h2>
<p>You can overload most operators in lua for your classes. You do this by simply
declaring a member function with the same name as an operator (the name of the
metamethods in lua). The operators you can overload are:</p>
<blockquote>
<ul class="simple">
<li>__add</li>
<li>__sub</li>
<li>__mul</li>
<li>__div</li>
<li>__pow</li>
<li>__lt</li>
<li>__le</li>
<li>__eq</li>
<li>__call</li>
<li>__unm</li>
<li>__tostring</li>
</ul>
</blockquote>
<p><tt class="literal"><span class="pre">__tostring</span></tt> isn't really an operator, but it's the metamethod that is called
by the standard library's <tt class="literal"><span class="pre">tostring()</span></tt> function. There's one strange behavior
regarding binary operators. You are not guaranteed that the self pointer you
get actually refers to an instance of your class. This is because lua doesn't
distinguish the two cases where you get the other operand as left hand value or
right hand value. Consider the following examples:</p>
<pre class="literal-block">
class 'my_class'

  function my_class:__init(v)
      self.val = v
  end
    
  function my_class:__sub(v)
      return my_class(self.val - v.val)
  end

  function my_class:__tostring()
      return self.val
  end
</pre>
<p>This will work well as long as you only subtracts instances of my_class with
each other. But If you want to be able to subtract ordinary numbers from your
class too, you have to manually check the type of both operands, including the
self object.</p>
<pre class="literal-block">
function my_class:__sub(v)
    if (type(self) == 'number') then
        return my_class(self - v.val)

    elseif (type(v) == 'number') then
        return my_class(self.val - v)
    
    else
        -- assume both operands are instances of my_class
        return my_class(self.val - v.val)

    end
end
</pre>
<p>The reason why <tt class="literal"><span class="pre">__sub</span></tt> is used as an example is because subtraction is not
commutative (the order of the operands matter). That's why luabind cannot
change order of the operands to make the self reference always refer to the
actual class instance.</p>
<p>If you have two different lua classes with an overloaded operator, the operator
of the right hand side type will be called. If the other operand is a C++ class
with the same operator overloaded, it will be prioritized over the lua class'
operator. If none of the C++ overloads matches, the lua class operator will be
called.</p>
</div>
<div class="section" id="finalizers">
<h2><a class="toc-backref" href="#id27" name="finalizers">10.3   Finalizers</a></h2>
<p>If an object needs to perform actions when it's collected we provide a
<tt class="literal"><span class="pre">__finalize</span></tt> function that can be overridden in lua-classes. The
<tt class="literal"><span class="pre">__finalize</span></tt> functions will be called on all classes in the inheritance
chain, starting with the most derived type.</p>
<pre class="literal-block">
...

function lua_testclass:__finalize()
    -- called when the an object is collected
end
</pre>
</div>
</div>
<div class="section" id="exceptions">
<h1><a class="toc-backref" href="#id28" name="exceptions">11   Exceptions</a></h1>
<p>If any of the functions you register throws an exception when called, that
exception will be caught by luabind and converted to an error string and
<tt class="literal"><span class="pre">lua_error()</span></tt> will be invoked. If the exception is a <tt class="literal"><span class="pre">std::exception</span></tt> or a
<tt class="literal"><span class="pre">const</span> <span class="pre">char*</span></tt> the string that is pushed on the lua stack, as error message,
will be the string returned by <tt class="literal"><span class="pre">std::exception::what()</span></tt> or the string itself
respectively. If the exception is unknown, a generic string saying that the
function threw an exception will be pushed.</p>
<p>Exceptions thrown from user defined functions have to be caught by luabind. If
they weren't they would be thrown through lua itself, which is usually compiled
as C code and doesn't support the stack-unwinding that exceptions imply.</p>
<p>Any function that invokes lua code may throw <tt class="literal"><span class="pre">luabind::error</span></tt>. This exception
means that a lua run-time error occurred. The error message is found on top of
the lua stack. The reason why the exception doesn't contain the error string
itself is because it would then require heap allocation which may fail. If an
exception class throws an exception while it is being thrown itself, the
application will be terminated.</p>
<p>Error's synopsis is:</p>
<pre class="literal-block">
class error : public std::exception
{
public:
    error(lua_State*);
    lua_State* state() const throw();
    virtual const char* what() const throw();
};
</pre>
<p>The state function returns a pointer to the lua state in which the error was
thrown. This pointer may be invalid if you catch this exception after the lua
state is destructed. If the lua state is valid you can use it to retrieve the
error message from the top of the lua stack.</p>
<p>An example of where the lua state pointer may point to an invalid state
follows:</p>
<pre class="literal-block">
struct lua_state
{
    lua_state(lua_State* L): m_L(L) {}
    ~lua_state() { lua_close(m_L); }
    operator lua_State*() { return m_L; }
    lua_State* m_L;
};

int main()
{
    try
    {
        lua_state L = lua_open();
        /* ... */
    }
    catch(luabind::error&amp; e)
    {
        lua_State* L = e.state();
        // L will now point to the destructed
        // lua state and be invalid
        /* ... */
    }
}
</pre>
<p>There's another exception that luabind may throw: <tt class="literal"><span class="pre">luabind::cast_failed</span></tt>,
this exception is thrown from <tt class="literal"><span class="pre">call_function&lt;&gt;</span></tt>, <tt class="literal"><span class="pre">call_member&lt;&gt;</span></tt> or when
<tt class="literal"><span class="pre">functor&lt;&gt;</span></tt> is invoked. It means that the return value from the lua function
couldn't be converted to a C++ value. It is also thrown from <tt class="literal"><span class="pre">object_cast&lt;&gt;</span></tt>
if the cast cannot be made.</p>
<p>The synopsis for <tt class="literal"><span class="pre">luabind::cast_failed</span></tt> is:</p>
<pre class="literal-block">
class cast_failed : public std::exception
{
public:
    cast_failed(lua_State*);
    lua_State* state() const throw();
    LUABIND_TYPE_INFO info() const throw();
    virtual const char* what() const throw();
};
</pre>
<p>Again, the state member function returns a pointer to the lua state where the
error occurred. See the example above to see where this pointer may be invalid.</p>
<p>The info member function returns the user defined <tt class="literal"><span class="pre">LUABIND_TYPE_INFO</span></tt>, which
defaults to a <tt class="literal"><span class="pre">const</span> <span class="pre">std::type_info*</span></tt>. This type info describes the type that
we tried to cast a lua value to.</p>
<p>If you have defined <tt class="literal"><span class="pre">LUABIND_NO_EXCEPTIONS</span></tt> none of these exceptions will be
thrown, instead you can set two callback functions that are called instead.
These two functions are only defined if <tt class="literal"><span class="pre">LUABIND_NO_EXCEPTIONS</span></tt> are defined.</p>
<pre class="literal-block">
luabind::set_error_callback(void(*)(lua_State*))
</pre>
<p>The function you set will be called when a runtime-error occur in lua code. You
can find an error message on top of the lua stack. This function is not
expected to return, if it does luabind will call <tt class="literal"><span class="pre">std::terminate()</span></tt>.</p>
<pre class="literal-block">
luabind::set_cast_failed_callback(void(*)(lua_State*, LUABIND_TYPE_INFO))
</pre>
<p>The function you set is called instead of throwing <tt class="literal"><span class="pre">cast_failed</span></tt>. This function
is not expected to return, if it does luabind will call <tt class="literal"><span class="pre">std::terminate()</span></tt>.</p>
</div>
<div class="section" id="policies">
<h1><a class="toc-backref" href="#id29" name="policies">12   Policies</a></h1>
<p>Sometimes it is necessary to control how luabind passes arguments and return
value, to do this we have policies. These are the policies that can be used:</p>
<div class="section" id="copy">
<h2><a class="toc-backref" href="#id30" name="copy">12.1   Copy</a></h2>
<p>This will make a copy of the parameter. This is the default behavior when
passing parameters by-value. Note that this can only be used when passing from
C++ to lua. This policy requires that the parameter type has a copy
constructor.</p>
<p>To use this policy you need to include <tt class="literal"><span class="pre">luabind/copy_policy.hpp</span></tt>.</p>
</div>
<div class="section" id="adopt">
<h2><a class="toc-backref" href="#id31" name="adopt">12.2   Adopt</a></h2>
<p>This will transfer ownership of the parameter.</p>
<p>Consider making a factory function in C++ and exposing it to lua:</p>
<pre class="literal-block">
base* create_base()
{
    return new base();
}

...

module(L)
[
    def(&quot;create_base&quot;, create_base)
];
</pre>
<p>Here we need to make sure lua understands that it should adopt the pointer
returned by the factory-function. This can be done using the adopt-policy.</p>
<pre class="literal-block">
module(L)
[
    def(L, &quot;create_base&quot;, adopt(return_value))
];
</pre>
<p>To specify multiple policies we just separate them with '+'.</p>
<pre class="literal-block">
base* set_and_get_new(base* ptr)
{
    base_ptrs.push_back(ptr);
    return new base();
}

module(L)
[
    def(&quot;set_and_get_new&quot;, &amp;set_and_get_new, 
        adopt(return_value) + adopt(_1))
];
</pre>
<p>When lua adopts a pointer, it will call delete on it. This means that it cannot
adopt pointers allocated with another allocator than new (no malloc for
example).</p>
<p>To use this policy you need to include <tt class="literal"><span class="pre">luabind/adopt_policy.hpp</span></tt>.</p>
</div>
<div class="section" id="dependency">
<h2><a class="toc-backref" href="#id32" name="dependency">12.3   Dependency</a></h2>
<p>The dependency policy is used to create life-time dependencies between values.
Consider the following example:</p>
<pre class="literal-block">
struct A
{
    B member;

    const B&amp; get_member()
    {
        return member;
    }
};
</pre>
<p>When wrapping this class, we would do something like:</p>
<pre class="literal-block">
module(L)
[
    class_&lt;A&gt;(&quot;A&quot;)
        .def(constructor&lt;&gt;())
        .def(&quot;get_member&quot;, &amp;A::get_member)
];
</pre>
<p>However, since the return value of get_member is a reference to a member of A,
this will create some life-time issues. For example:</p>
<pre class="literal-block">
Lua 5.0  Copyright (C) 1994-2003 Tecgraf, PUC-Rio
a = A()
b = a:get_member() -- b points to a member of a
a = nil
collectgarbage(0)  -- since there are no references left to a, it is
                   -- removed
                   -- at this point, b is pointing into a removed object
</pre>
<p>When using the dependency-policy, it is possible to tell luabind to tie the
lifetime of one object to another, like this:</p>
<pre class="literal-block">
module(L)
[
    class_&lt;A&gt;(&quot;A&quot;)
        .def(constructor&lt;&gt;())
        .def(&quot;get_member&quot;, &amp;A::get_member, dependency(result, self))
];
</pre>
<p>This will create a dependency between the return-value of the function, and the
self-object. This means that the self-object will be kept alive as long as the
result is still alive.</p>
<pre class="literal-block">
Lua 5.0  Copyright (C) 1994-2003 Tecgraf, PUC-Rio
a = A()
b = a:get_member() -- b points to a member of a
a = nil
collectgarbage(0)  -- a is dependent on b, so it isn't removed
b = nil
collectgarbage(0)  -- all dependencies to a gone, a is removed
</pre>
<p>To use this policy you need to include <tt class="literal"><span class="pre">luabind/dependency_policy.hpp</span></tt>.</p>
</div>
<div class="section" id="return-reference-to">
<h2><a class="toc-backref" href="#id33" name="return-reference-to">12.4   Return reference to</a></h2>
<p>It is very common to return references to arguments or the this-pointer to
allow for chaining in C++.</p>
<pre class="literal-block">
struct A
{
    float val;

    A&amp; set(float v)
    {
        val = v;
        return *this;
    }
};
</pre>
<p>When luabind generates code for this, it will create a new object for the
return-value, pointing to the self-object. This isn't a problem, but could be a
bit inefficient. When using the return_reference_to-policy we have the ability
to tell luabind that the return-value is already on the lua stack.</p>
<pre class="literal-block">
module(L)
[
    class_&lt;A&gt;(&quot;A&quot;)
        .def(constructor&lt;&gt;())
        .def(&quot;set&quot;, &amp;A::set, return_reference_to(self))
];
</pre>
<p>Instead of creating a new object, luabind will just copy the object that is
already on the stack.</p>
<div class="warning">
<p class="admonition-title">Warning</p>
This policy ignores all type information and should be used only it 
situations where the parameter type is a perfect match to the 
return-type (such as in the example).</div>
<p>To use this policy you need to include <tt class="literal"><span class="pre">luabind/return_reference_to_policy.hpp</span></tt>.</p>
</div>
<div class="section" id="out-value">
<h2><a class="toc-backref" href="#id34" name="out-value">12.5   Out value</a></h2>
<p>This policy makes it possible to wrap functions that take non const references
as its parameters with the intention to write return values to them.</p>
<pre class="literal-block">
void f(float&amp; val) { val = val + 10.f; }
</pre>
<p>or</p>
<pre class="literal-block">
void f(float* val) { *val = *val + 10.f; }
</pre>
<p>Can be wrapped by doing:</p>
<pre class="literal-block">
module(L)
[
    def(&quot;f&quot;, &amp;f, out_value(_1))
];
</pre>
<p>When invoking this function from lua it will return the value assigned to its 
parameter.</p>
<pre class="literal-block">
Lua 5.0  Copyright (C) 1994-2003 Tecgraf, PUC-Rio
&gt; a = f(10)
&gt; print(a)
20
</pre>
<p>When this policy is used in conjunction with user define types we often need 
to do ownership transfers.</p>
<pre class="literal-block">
struct A;

void f1(A*&amp; obj) { obj = new A(); }
void f2(A** obj) { *obj = new A(); }
</pre>
<p>Here we need to make sure luabind takes control over object returned, for 
this we use the adopt policy:</p>
<pre class="literal-block">
module(L)
[
    class_&lt;A&gt;(&quot;A&quot;),
    def(&quot;f1&quot;, &amp;f1, out_value(_1, adopt(_2)))
    def(&quot;f2&quot;, &amp;f2, out_value(_1, adopt(_2)))
];
</pre>
<p>Here we are using adopt as an internal policy to out_value. The index 
specified, _2, means adopt will be used to convert the value back to lua. 
Using _1 means the policy will be used when converting from lua to C++.</p>
<p>To use this policy you need to include <tt class="literal"><span class="pre">luabind/out_value_policy.hpp</span></tt>.</p>
</div>
<div class="section" id="pure-out-value">
<h2><a class="toc-backref" href="#id35" name="pure-out-value">12.6   Pure out value</a></h2>
<p>This policy works in exactly the same way as out_value, except that it 
replaces the parameters with default-constructed objects.</p>
<pre class="literal-block">
void get(float&amp; x, float&amp; y)
{
    x = 3.f;
    y = 4.f;
}

...

module(L)
[
    def(&quot;get&quot;, &amp;get, 
        pure_out_value(_1) + pure_out_value(_2))
];
</pre>
<pre class="literal-block">
Lua 5.0  Copyright (C) 1994-2003 Tecgraf, PUC-Rio
&gt; x, y = get()
&gt; print(x, y)
3    5
</pre>
<p>Like out_value, it is possible to specify an internal policy used then 
converting the values back to lua.</p>
<pre class="literal-block">
void get(test_class*&amp; obj)
{
    obj = new test_class();
}

...

module(L)
[
    def(&quot;get&quot;, &amp;get, pure_out_value(_1, adopt(_1)))
];
</pre>
</div>
<div class="section" id="discard-result">
<h2><a class="toc-backref" href="#id36" name="discard-result">12.7   Discard result</a></h2>
<p>This is a very simple policy which makes it possible to throw away 
the value returned by a C++ function, instead of converting it to 
lua. This example makes sure the this reference never gets converted 
to lua.</p>
<pre class="literal-block">
struct simple
{
    simple&amp; set_name(const std::string&amp; n)
    {
        name = n;
        return *this;
    }

    std::string name;
};

...

module(L)
[
    class_&lt;simple&gt;(&quot;simple&quot;)
        .def(&quot;set_name&quot;, &amp;simple::set_name, discard_result)
];
</pre>
<p>To use this policy you need to include <tt class="literal"><span class="pre">luabind/discard_result_policy.hpp</span></tt>.</p>
</div>
<div class="section" id="return-stl-iterator">
<h2><a class="toc-backref" href="#id37" name="return-stl-iterator">12.8   Return STL iterator</a></h2>
<p>This policy converts an STL container to a generator function that can be used
in lua to iterate over the container. It works on any container that defines
<tt class="literal"><span class="pre">begin()</span></tt> and <tt class="literal"><span class="pre">end()</span></tt> member functions (they have to return iterators). It
can be used like this:</p>
<pre class="literal-block">
struct A
{
    std::vector&lt;std::string&gt; names;
};


module(L)
[
    class_&lt;A&gt;(&quot;A&quot;)
        .def_readwrite(&quot;names&quot;, &amp;A::names, return_stl_iterator)
];
</pre>
<p>The lua code to iterate over the container:</p>
<pre class="literal-block">
a = A()

for name in a.names do
  print(name)
end
</pre>
<p>To use this policy you need to include <tt class="literal"><span class="pre">luabind/iterator_policy.hpp</span></tt>.</p>
</div>
<div class="section" id="yield">
<h2><a class="toc-backref" href="#id38" name="yield">12.9   Yield</a></h2>
<p>This policy will cause the function to always yield the current thread when 
returning. See the lua manual for restrictions on yield.</p>
</div>
</div>
<div class="section" id="splitting-up-the-registration">
<h1><a class="toc-backref" href="#id39" name="splitting-up-the-registration">13   Splitting up the registration</a></h1>
<p>a.cpp:</p>
<pre class="literal-block">
luabind::scope register_a()
{
    return 
        class_&lt;a&gt;(&quot;a&quot;)
            .def(&quot;f&quot;, &amp;a::f)
            ;
}
</pre>
<p>b.cpp:</p>
<pre class="literal-block">
luabind::scope register_b()
{
    return 
        class_&lt;b&gt;(&quot;b&quot;)
            .def(&quot;g&quot;, &amp;b::g)
            ;
}
</pre>
<p>module_ab.cpp:</p>
<pre class="literal-block">
luabind::scope register_a();
luabind::scope register_b();

void register_module(lua_State* L)
{
    module(&quot;b&quot;, L)
    [
        register_a(),
        register_b()
    ];
}
</pre>
</div>
<div class="section" id="configuration">
<h1><a class="toc-backref" href="#id40" name="configuration">14   Configuration</a></h1>
<p>As mentioned in the <a class="reference" href="http://www.lua.org/manual/5.0/manual.html">Lua documentation</a>, it is possible to pass an
error handler function to <tt class="literal"><span class="pre">lua_pcall()</span></tt>. Luabind makes use of 
<tt class="literal"><span class="pre">lua_pcall()</span></tt> internally when calling methods and functions. It is
possible to set the error handler function that Luabind will use 
globally:</p>
<pre class="literal-block">
typedef void(*pcall_callback_fun)(lua_State*);
void set_pcall_callback(pcall_callback_fun fn);
</pre>
<p>This is primarily useful for adding more information to the error message
returned by a failed protected call.</p>
<div class="section" id="build-options">
<h2><a class="toc-backref" href="#id41" name="build-options">14.1   Build options</a></h2>
<p>There are a number of configuration options available when building luabind.
It is very important that your project has the exact same conmfiguration 
options as the ones given when the library was build! The exceptions are the
<tt class="literal"><span class="pre">LUABIND_MAX_ARITY</span></tt> and <tt class="literal"><span class="pre">LUABIND_MAX_BASES</span></tt> which are template-based 
options and only matters when you use the library (which means they can 
differ from the settings of the library).</p>
<p>The default settings which will be used if no other settings are given
can be found in <tt class="literal"><span class="pre">luabind/config.hpp</span></tt>.</p>
<p>If you want to change the settings of the library, you can modify the 
config file. It is included and used by all makefiles. You can change paths
to lua and boost in there as well.</p>
<dl>
<dt>LUABIND_MAX_ARITY</dt>
<dd>Controls the maximum arity of functions that are registered with luabind. 
You can't register functions that takes more parameters than the number 
this macro is set to. It defaults to 5, so, if your functions have greater 
arity you have to redefine it. A high limit will increase compilation time.</dd>
<dt>LUABIND_MAX_BASES</dt>
<dd>Controls the maximum number of classes one class can derive from in 
luabind (the number of classes specified within <tt class="literal"><span class="pre">bases&lt;&gt;</span></tt>). 
<tt class="literal"><span class="pre">LUABIND_MAX_BASES</span></tt> defaults to 4. A high limit will increase 
compilation time.</dd>
<dt>LUABIND_NO_ERROR_CHECKING</dt>
<dd><p class="first">If this macro is defined, all the lua code is expected only to make legal 
calls. If illegal function calls are made (e.g. giving parameters that 
doesn't match the function signature) they will not be detected by luabind
and the application will probably crash. Error checking could be disabled 
when shipping a release build (given that no end-user has access to write 
custom lua code). Note that function parameter matching will be done if a 
function is overloaded, since otherwise it's impossible to know which one 
was called. Functions will still be able to throw exceptions when error 
checking is disabled.</p>
<p class="last">If a functions throws an exception it will be caught by luabind and 
propagated with <tt class="literal"><span class="pre">lua_error()</span></tt>.</p>
</dd>
<dt>LUABIND_NO_EXCEPTIONS</dt>
<dd><p class="first">This define will disable all usage of try, catch and throw in luabind. 
This will in many cases disable run-time errors, when performing invalid 
casts or calling lua functions that fails or returns values that cannot 
be converted by the given policy. luabind requires that no function called 
directly or indirectly by luabind throws an exception (throwing exceptions 
through lua has undefined behavior).</p>
<p class="last">Where exceptions are the only way to get an error report from luabind, 
they will be replaced with calls to the callback functions set with
<tt class="literal"><span class="pre">set_error_callback()</span></tt> and <tt class="literal"><span class="pre">set_cast_failed_callback()</span></tt>.</p>
</dd>
<dt>LUA_API</dt>
<dd>If you want to link dynamically against lua, you can set this define to 
the import-keyword on your compiler and platform. On windows in devstudio 
this should be <tt class="literal"><span class="pre">__declspec(dllimport)</span></tt> if you want to link against lua 
as a dll.</dd>
<dt>LUABIND_EXPORT, LUABIND_IMPORT</dt>
<dd>If you want to link against luabind as a dll (in devstudio), you can 
define <tt class="literal"><span class="pre">LUABIND_EXPORT</span></tt> to <tt class="literal"><span class="pre">__declspec(dllexport)</span></tt> and 
<tt class="literal"><span class="pre">LUABIND_IMPORT</span></tt> to <tt class="literal"><span class="pre">__declspec(dllimport)</span></tt>. 
Note that you have to link against lua as a dll aswell, to make it work.</dd>
<dt>LUABIND_TYPE_INFO, LUABIND_TYPE_INFO_EQUAL(i1,i2), LUABIND_TYPEID(t), LUABIND_INVALID_TYPE_INFO</dt>
<dd><p class="first">If you don't want to use the RTTI supplied by C++ you can supply your own 
type-info structure with the <tt class="literal"><span class="pre">LUABIND_TYPE_INFO</span></tt> define. Your type-info 
structure must be copyable and must be able to compare itself against 
other type-info structures. You supply the compare function through the 
<tt class="literal"><span class="pre">LUABIND_TYPE_INFO_EQUAL()</span></tt> define. It should compare the two type-info 
structures it is given and return true if they represent the same type and
false otherwise. You also have to supply a function to generate your 
type-info structure. You do this through the <tt class="literal"><span class="pre">LUABIND_TYPEID()</span></tt> define. 
It should return your type-info structure and it takes a type as its 
parameter. That is, a compile time parameter. 
<tt class="literal"><span class="pre">LUABIND_INVALID_TYPE_INFO</span></tt> macro should be defined to an invalid type. 
No other type should be able to produce this type info. To use it you 
probably have to make a traits class with specializations for all classes 
that you have type-info for. Like this:</p>
<pre class="literal-block">
class A;
class B;
class C;

template&lt;class T&gt; struct typeinfo_trait;

template&lt;&gt; struct typeinfo_trait&lt;A&gt; { enum { type_id = 0 }; };
template&lt;&gt; struct typeinfo_trait&lt;B&gt; { enum { type_id = 1 }; };
template&lt;&gt; struct typeinfo_trait&lt;C&gt; { enum { type_id = 2 }; };
</pre>
<p>If you have set up your own RTTI system like this (by using integers to
identify types) you can have luabind use it with the following defines:</p>
<pre class="literal-block">
#define LUABIND_TYPE_INFO const std::type_info*
#define LUABIND_TYPEID(t) &amp;typeid(t)
#define LUABIND_TYPE_INFO_EQUAL(i1, i2) *i1 == *i2
#define LUABIND_INVALID_TYPE_INFO &amp;typeid(detail::null_type)
</pre>
<p class="last">Currently the type given through <tt class="literal"><span class="pre">LUABIND_TYPE_INFO</span></tt> must be less-than 
comparable!</p>
</dd>
<dt>NDEBUG</dt>
<dd>This define will disable all asserts and should be defined in a release 
build.</dd>
</dl>
</div>
</div>
<div class="section" id="implementation-notes">
<h1><a class="toc-backref" href="#id42" name="implementation-notes">15   Implementation notes</a></h1>
<p>The classes and objects are implemented as user data in lua. To make sure that
the user data really is the internal structure it is supposed to be, we tag
their metatables. A user data who's metatable contains a boolean member named
<tt class="literal"><span class="pre">__luabind_classrep</span></tt> is expected to be a class exported by luabind. A user
data who's metatable contains a boolean member named <tt class="literal"><span class="pre">__luabind_class</span></tt> is
expected to be an instantiation of a luabind class.</p>
<p>This means that if you make your own user data and tags its metatable with the
exact same names, you can very easily fool luabind and crash the application.</p>
<p>In the lua registry, luabind keeps an entry called <tt class="literal"><span class="pre">__luabind_classes</span></tt>. It
should not be removed or overwritten.</p>
<p>In the global table, a variable called <tt class="literal"><span class="pre">super</span></tt> is used every time a
constructor in a lua-class is called. This is to make it easy for that
constructor to call its base class' constructor. So, if you have a global
variable named super it may very well be overwritten. This is probably not the
best solution, and this restriction may very well be removed in the future.</p>
<p>Luabind uses two upvalues for functions that it registers. The first is a
userdata containing a list of overloads for the function, the other is a light
userdata with the value 0x1337, this last value is used to identify functions
registered by luabind. It should be virtually impossible to have such a pointer
as secondary upvalue by pure chance. This means, if you are trying to replace
an existing function with a luabind function, luabind will see that the
secondary upvalue isn't the magic id number and replace it. If it can identify
the function to be a luabind function, it won't replace it, but rather add
another overload to it.</p>
<p>Inside the luabind namespace, there's another namespace called detail. This
namespace contains non-public classes and are not supposed to be used directly.</p>
</div>
<div class="section" id="error-messages">
<h1><a class="toc-backref" href="#id43" name="error-messages">16   Error messages</a></h1>
<ul>
<li><p class="first"><cite>the attribute '&lt;class-name&gt;.&lt;attribute-name&gt;' is read only</cite></p>
<blockquote>
<p>There is no data member named &lt;attribute-name&gt; in the class &lt;class-name&gt;,
or there's no setter-method registered on that property name. See the 
properties section.</p>
</blockquote>
</li>
<li><p class="first"><cite>the attribute '&lt;class-name&gt;.&lt;attribute-name&gt;' is of type: (&lt;class-name&gt;)
and does not match (&lt;class_name&gt;)</cite></p>
<blockquote>
<p>This error is generated if you try to assign an attribute with a value 
of a type that cannot be converted to the attribute's type.</p>
</blockquote>
</li>
<li><p class="first"><cite>&lt;class-name&gt;() threw an exception, &lt;class-name&gt;:&lt;function-name&gt;() threw an 
exception</cite></p>
<blockquote>
<p>The class' constructor or member function threw an unknown exception.
Known exceptions are const char*, std::exception. See the 
<a class="reference" href="#exceptions">exceptions</a> section.</p>
</blockquote>
</li>
<li><p class="first"><cite>no overload of '&lt;class-name&gt;:&lt;function-name&gt;' matched the arguments 
(&lt;parameter-types&gt;)</cite></p>
</li>
<li><p class="first"><cite>no match for function call '&lt;function-name&gt;' with the parameters 
(&lt;parameter-types&gt;)</cite></p>
</li>
<li><p class="first"><cite>no constructor of &lt;class-name&gt; matched the arguments (&lt;parameter-types&gt;)</cite></p>
</li>
<li><p class="first"><cite>no operator &lt;operator-name&gt; matched the arguments (&lt;parameter-types&gt;)</cite></p>
<blockquote>
<p>No function/operator with the given name takes the parameters you gave 
it. You have either misspelled the function name, or given it incorrect
parameters. This error is followed by a list of possible candidate 
functions to help you figure out what parameter has the wrong type. If
the candidate list is empty there's no function at all with that name.
See the signature matching section.</p>
</blockquote>
</li>
<li><p class="first"><cite>call of overloaded '&lt;class-name&gt;:&lt;function-name&gt;(&lt;parameter-types&gt;)' is 
ambiguous</cite></p>
</li>
<li><p class="first"><cite>ambiguous match for function call '&lt;function-name&gt;' with the parameters 
(&lt;parameter-types&gt;)</cite></p>
</li>
<li><p class="first"><cite>call of overloaded constructor '&lt;class-name&gt;(&lt;parameter-types&gt;)' is 
ambiguous</cite></p>
</li>
<li><p class="first"><cite>call of overloaded operator &lt;operator-name&gt; (&lt;parameter-types&gt;) is 
ambiguous</cite></p>
<blockquote>
<p>This means that the function/operator you are trying to call has at least
one other overload that matches the arguments just as good as the first
overload.</p>
</blockquote>
</li>
<li><p class="first"><cite>cannot derive from C++ class '&lt;class-name&gt;'. It does not have a wrapped
type.</cite></p>
<blockquote>
<p>You are trying to derive a lua class from a C++ class that doesn't have a
wrapped type. You have to give your C++ class a wrapped type when you 
register it with lua. See the deriving in lua section.</p>
</blockquote>
</li>
<li><p class="first"><cite>derived class must call super on base</cite></p>
</li>
<li><p class="first"><cite>cannot set property '&lt;class-name&gt;.&lt;attribute_name&gt;' because it's read only</cite></p>
<blockquote>
<p>The attribute you are trying to set is registered as read only. If you want
it to be writeable you have to change your class registration and use
def_readwrite() instead of def_readonly(). Alternatively (if your 
attribute is a property with getter and setter functions), you have to 
give a setter function when declaring your attribute. See the properties section.</p>
</blockquote>
</li>
<li><p class="first"><cite>no static '&lt;enum-name&gt;' in class '&lt;class-name&gt;'</cite></p>
<blockquote>
<p>You will get this error message if you are trying to access an enum that
doesn't exist. Read about how to declare enums.</p>
</blockquote>
</li>
<li><p class="first"><cite>expected base class</cite></p>
<blockquote>
<p>You have written a malformed class definition in lua. The format is: class
'&lt;class-name&gt;' [&lt;base-class&gt;]. If you don't want to derive from a base 
class, you have to break the line directly after the class declaration.</p>
</blockquote>
</li>
<li><p class="first"><cite>invalid construct, expected class name</cite></p>
<blockquote>
<p>You have written a malformed class definition in lua. The class function
expects a string as argument. That string is the name of the lua class to
define.</p>
</blockquote>
</li>
</ul>
</div>
<div class="section" id="faq">
<h1><a class="toc-backref" href="#id44" name="faq">17   FAQ</a></h1>
<dl>
<dt>What's up with __cdecl and __stdcall? </dt>
<dd>If you're having problem with functions
that cannot be converted from 'void (__stdcall <em>)(int,int)' to 'void 
(__cdecl</em>)(int,int)'. You can change the project settings to make the
compiler generate functions with __cdecl calling conventions. This is 
a problem in developer studio.</dd>
<dt>What's wrong with functions taking variable number of arguments?</dt>
<dd>You cannot register a function with ellipses in its signature. Since 
ellipses don't preserve type safety, those should be avoided anyway.</dd>
<dt>Internal structure overflow in VC</dt>
<dd>If you, in visual studio, get fatal error C1204: compiler limit : 
internal structure overflow. You should try to split that compilation 
unit up in smaller ones.</dd>
<dt>What's wrong with precompiled headers in VC?</dt>
<dd>Visual Studio doesn't like anonymous namespaces in its precompiled 
headers. If you encounter this problem you can disable precompiled 
headers for the compilation unit (cpp-file) that uses luabind.</dd>
<dt>error C1076: compiler limit - internal heap limit reached in VC</dt>
<dd>In visual studio you will probably hit this error. To fix it you have to
increase the internal heap with a command-line option. We managed to
compile the test suit with /Zm300, but you may need a larger heap then 
that.</dd>
<dt>error C1055: compiler limit <span class="classifier-delimiter">:</span> <span class="classifier">out of keys in VC</span></dt>
<dd>It seems that this error occurs when too many assert() are used in a
program, or more specifically, the __LINE__ macro. It seems to be fixed by
changing /ZI (Program database for edit and continue) to /Zi 
(Program database).</dd>
<dt>How come my executable is huge?</dt>
<dd><p class="first">If you're compiling in debug mode, you will probably have a lot of
debug-info and symbols (luabind consists of a lot of functions). Also, 
if built in debug mode, no optimizations were applied, luabind relies on 
that the compiler is able to inline functions. If you built in release 
mode, try running strip on your executable to remove export-symbols, 
this will trim down the size.</p>
<p class="last">Our tests suggests that cygwin's gcc produces much bigger executables 
compared to gcc on other platforms and other compilers.</p>
</dd>
</dl>
<!-- HUH?! // check the magic number that identifies luabind's functions  -->
<dl>
<dt>Can I register class templates with luabind?</dt>
<dd><p class="first">Yes you can, but you can only register explicit instantiations of the 
class. Because there's no lua counterpart to C++ templates. For example, 
you can register an explicit instantiation of std::vector&lt;&gt; like this:</p>
<pre class="last literal-block">
module(L)
[
    class_&lt;std::vector&lt;int&gt; &gt;(&quot;vector&quot;)
        .def(constructor&lt;int&gt;)
        .def(&quot;push_back&quot;, &amp;std::vector&lt;int&gt;::push_back)
];
</pre>
</dd>
</dl>
<!-- Again, irrelevant to docs: Note that the space between the two > is required by C++. -->
<dl>
<dt>Do I have to register destructors for my classes?</dt>
<dd><p class="first">No, the destructor of a class is always called by luabind when an 
object is collected. Note that lua has to own the object to collect it.
If you pass it to C++ and gives up ownership (with adopt policy) it will 
no longer be owned by lua, and not collected.</p>
<p class="last">If you have a class hierarchy, you should make the destructor virtual if 
you want to be sure that the correct destructor is called (this apply to C++ 
in general).</p>
</dd>
</dl>
<!-- And again, the above is irrelevant to docs. This isn't a general C++ FAQ. -->
<dl>
<dt>Fatal Error C1063 compiler limit <span class="classifier-delimiter">:</span> <span class="classifier">compiler stack overflow in VC</span></dt>
<dd>VC6.5 chokes on warnings, if you are getting alot of warnings from your 
code try suppressing them with a pragma directive, this should solve the 
problem.</dd>
<dt>Crashes when linking against luabind as a dll in windows</dt>
<dd>When you build luabind, lua and you project, make sure you link against 
the runtime dynamically (as a dll).</dd>
<dt>I cannot register a function with a non-const parameter</dt>
<dd>This is because there is no way to get a reference to a lua value. Have 
a look at out_value and pure_out_value policies.</dd>
</dl>
</div>
<div class="section" id="known-issues">
<h1><a class="toc-backref" href="#id45" name="known-issues">18   Known issues</a></h1>
<ul class="simple">
<li>You cannot use strings with extra nulls in them as member names that refers
to C++ members.</li>
<li>If one class registers two functions with the same name and the same 
signature, there's currently no error. The last registered function will 
be the one that's used.</li>
<li>In vc7, classes can not be called test.</li>
</ul>
<!-- remove? - Visual studio have problems selecting the correct overload of std::swap() 
for luabind::object.  -->
<ul class="simple">
<li>If you register a function and later rename it, error messages will use the 
original function name.</li>
</ul>
</div>
<div class="section" id="acknowledgments">
<h1><a class="toc-backref" href="#id46" name="acknowledgments">19   Acknowledgments</a></h1>
<p>This library was written by Daniel Wallin and Arvid Norberg. © Copyright 2003. 
All rights reserved.</p>
<p>This library was inspired by Dave Abrahams' Boost.Python library which can be 
found in the <a class="reference" href="http://www.boost.org">boost</a> library.</p>
<p>Evan Wies has contributed with thorough testing and countless bug reports and
feature ideas.</p>
<p>Thanks to Umeå university for providing development and testing hardware.</p>
</div>
</div>
</body>
</html>
